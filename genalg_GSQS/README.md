# Workflow for GSQS generator with GA method

The following workflow is used to generate generalized special
quasi-random (GSQS) structures using an optimizer. The optimizer
demonstrated here is a genetic algorithm. On a high level, this is
a generalization of the method developed by Alex Zunger for traditional
special-quasi-random structures, which are commonly used to model
alloys in DFT.

## REQUIREMENTS

Download the Structure_Generation code from this repo.
Add the structure generation code to your pythonpath variable:
`export PYTHONPATH=/path/to/Structure_Generation`

Download lammps and build with ACE and python packages (details
may be found on the FitSNAP docs: https://fitsnap.github.io/Installation.html#fitsnap-installation )
Doing so requires the following compilation flags

<pre><code>
cmake ../cmake -DLAMMPS_EXCEPTIONS=yes \
              -DBUILD_SHARED_LIBS=yes \
              -DMLIAP_ENABLE_PYTHON=yes \
              -DPKG_PYTHON=yes \
              -DPKG_ML-SNAP=yes \
              -DPKG_ML-IAP=yes \
              -DPKG_ML-PACE=yes \
              -DPKG_SPIN=yes \
              -DPYTHON_EXECUTABLE:FILEPATH=`which python`
</code></pre>

Most functionality will also require the installation of the
ASE python module - install with:

`pip install ase`

## Workflow

### Define target structure and/or target descriptor distribution 

GSQS can target random alloy configurations like tradtional fixed-lattice
SQS, but it can also target a wider range of structure + composition
combinations. For this example, we aim to reproduce simple crystalline 
ordered compounds AND/OR traditional SQS in later steps. The scripts 
are set up for the former. <b>step 1</b> in the workflow is to define
the target structure based on a distribution of ACE descriptors. More
generally, all that is needed is the distribution of ACE descriptors.

For this example, a target structure is first generated by <b>step 1a</b>:

`python build_example_target.py`

which uses ASE to build a Ca/Mg alloy target in BCC phase,
making a structure file to be read at later steps. If this step
fails, ASE may not be found correctly or is missing.

The corresponding descriptors, <b>step 1b</b>, are obtained for this
structure:

`python get_target.py`

This script reads the structure from <b>step 1a</b> and generates the
corresponding ACE descriptor distribution from it. This distribution
will be saved to `.npy` files. 
This step will run if LAMMPS and lammps-python are compiled correctly
with ACE.

### Run an optimizer to find a corresponding GSQS

The goal of GSQS is to take a descriptor distribution (e.g.  <b>step 1</b>)
and find a structure (or set of structures) that provide a best fit. Ideally
in a smaller supercell. While this example maintains the same cell size for 
demonstration purposes, we will generally aim to get a smaller structure than
the target (or may not even have a structure if we only know descriptor distributions
we want).

After successfully running the scripts in <b>step 1a</b> and <b>step 1b</b> 
you will need to run the actual optimizer script. The GA script itself may be
ran in the background:

`python genalg_opt.py &> outopt.txt &`

The output will be printed forces and a collection of candidate structures that
have the best scores out of their respective generations.

### other files

The other files/folders in this directory are:

`coupling_coefficients.yace` : hyperparameters and defining quantities for the ACE
descriptors

`reference` : a quick example output from the workflow outlined above

### NOTES 

in the future, this workflow will probably be collected into a single script/module
